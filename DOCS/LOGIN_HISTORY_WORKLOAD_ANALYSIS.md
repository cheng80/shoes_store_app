# 로그인 히스토리 기능 추가 시 작업량 분석

**작성일**: 2025-01-XX  
**목적**: 로그인 히스토리 기능 추가 시 담당자 1의 작업량 분석 및 협업 방안 제안

---

## 📊 현재 담당자 1의 작업량

| 항목 | 내용 |
|------|------|
| **화면 수** | 6개 |
| **주요 작업** | 사용자/관리자 로그인 및 개인정보 수정 |
| **복잡도** | 낮음 (단순 CRUD) |
| **기술 스택** | MySQL, FastAPI |

### 담당 화면
1. 사용자 로그인
2. 사용자 메뉴 드로어
3. 사용자-회원가입
4. 사용자-개인정보 수정
5. 관리자-로그인
6. 관리자-드로어 메뉴
7. 관리자-개인정보 수정

---

## 🔍 로그인 히스토리 기능 추가 시 필요한 작업

### 1. 백엔드 작업
- ✅ **로그인 API 수정** (사용자/관리자 모두)
  - 로그인 성공 시 SQLite에 기록 추가
  - 해시 처리 로직 구현
  - 디바이스 정보, 위치 정보 처리 (선택)
- ✅ **SQLite 스키마 설계 및 구현**
  - 테이블 생성
  - 인덱스 설정
- ✅ **로그인 히스토리 조회 API**
  - 사용자별 히스토리 조회
  - 필터링, 정렬 기능

### 2. 프론트엔드 작업
- ✅ **로그인 히스토리 조회 화면** (1개 화면 추가)
  - 사용자 로그인 히스토리 목록
  - 이전 로그인 정보 표시
- ✅ **로그인 API 호출 수정**
  - 로그인 성공 시 SQLite 기록 호출
- ✅ **패키지 추가** (선택)
  - `device_info_plus`: 디바이스 정보 획득
  - `geolocator`: 위치 정보 획득 (또는 백엔드에서 IP 기반)

### 3. 기술 스택 추가
- ✅ **SQLite** (새로운 기술 스택)
- ✅ **해시 처리** (SHA-256)
- ✅ **디바이스 정보 획득** (패키지 필요)

---

## ⚠️ 작업량 증가 분석

### 화면 수
- **현재**: 6개
- **추가 후**: 7개 (+1개)
- **증가율**: 16.7%

### 복잡도
- **현재**: 낮음 (단순 CRUD)
- **추가 후**: 중간 (SQLite 작업, 해시 처리, 패키지 연동)
- **복잡도 증가**: 낮음 → 중간

### 기술 스택
- **현재**: MySQL, FastAPI
- **추가 후**: MySQL, SQLite, FastAPI, 해시 처리, 디바이스 정보 패키지
- **기술 스택 증가**: 2개 → 5개

### 예상 작업 시간
- **백엔드**: 2-3일 (SQLite 스키마 설계, API 수정, 해시 처리)
- **프론트엔드**: 2-3일 (화면 개발, 패키지 연동, API 연동)
- **총 예상 시간**: 4-6일

---

## 💡 협업 방안 제안

### 옵션 1: 다른 담당자가 도와주기 (권장) ⭐

**장점:**
- ✅ 담당자 1의 작업량 분산
- ✅ SQLite 작업을 다른 담당자가 담당하여 기술 스택 다양화
- ✅ 로그인 히스토리 조회 화면을 다른 담당자가 개발하여 화면 수 분산
- ✅ 협업을 통한 지식 공유

**담당자별 역할 분담:**

#### 담당자 1 (기존 작업 + 로그인 API 수정)
- 로그인 API 수정 (SQLite 기록 호출 추가)
- 해시 처리 로직 구현
- **예상 작업 시간**: 1-2일

#### 담당자 4 (SQLite 작업 + 조회 화면) ⭐
- SQLite 스키마 설계 및 구현
- 로그인 히스토리 조회 API 개발
- 로그인 히스토리 조회 화면 개발
- **예상 작업 시간**: 3-4일
- **이유**: 조회 화면 개발 경험 보유, 주문/반품 조회와 유사한 패턴

**권장 담당자:**
- **담당자 4**: 4개 화면 (높은 복잡도) - 하지만 조회 화면 개발 경험 있음, 주문/반품 조회와 유사한 패턴
- **담당자 2**: 2개 화면이지만 **복잡도 매우 높음** ⚠️
  - 6개 테이블 JOIN (product + 5개 카테고리 테이블)
  - 카테고리별 필터링 API 다수 개발 필요
  - 제조사별 조회 API 개발 필요
  - **SQLite 작업 추가 시 과부하 가능성 높음**

### 옵션 2: 담당자 1이 모두 담당

**장점:**
- ✅ 로그인 관련 작업이 한 곳에 집중
- ✅ 일관성 있는 코드 구조

**단점:**
- ❌ 담당자 1의 작업량 증가 (6개 → 7개 화면)
- ❌ 복잡도 증가 (낮음 → 중간)
- ❌ SQLite 작업을 처음부터 학습해야 함
- ❌ 다른 담당자보다 작업량이 많아짐

---

## 📋 최종 권장안

### 협업 방식 (옵션 1 권장)

**1단계: 담당자 1 (로그인 API 수정)**
- 로그인 성공 시 SQLite 기록 호출 추가
- 해시 처리 로직 구현
- **예상 기간**: 1-2일

**2단계: 담당자 4 (SQLite 작업 + 조회 화면)**
- SQLite 스키마 설계 및 구현
- 로그인 히스토리 조회 API 개발
- 로그인 히스토리 조회 화면 개발
- **예상 기간**: 3-4일

**협업 포인트:**
- 담당자 1이 해시 처리 로직과 API 호출 방식을 담당자 4와 공유
- 담당자 4가 SQLite 스키마와 조회 API를 개발 (주문/반품 조회와 유사한 패턴)
- 담당자 1이 로그인 API에 통합

**담당자 2 제외 이유:**
- 화면 수는 적지만 복잡도 매우 높음
  - 6개 테이블 JOIN (product + 5개 카테고리 테이블)
  - 카테고리별 필터링 API 다수 개발 필요
  - 제조사별 조회 API 개발 필요
- SQLite 작업 추가 시 과부하 가능성 높음

---

## 🎯 결론

**로그인 히스토리 기능 추가 시 담당자 1이 모두 담당하면:**
- 화면 수: 6개 → 7개 (+16.7%)
- 복잡도: 낮음 → 중간
- 기술 스택: 2개 → 5개
- **과부하 가능성: 높음** ⚠️

**다른 담당자가 도와주는 경우:**
- 담당자 1: 로그인 API 수정만 (1-2일)
- 담당자 2/4: SQLite 작업 + 조회 화면 (3-4일)
- **작업량 분산: 효과적** ✅

**최종 권장:**
- ✅ **다른 담당자가 도와주는 방식을 권장합니다**
- ✅ **담당자 4와 협업하는 것을 추천** ⭐
  - 조회 화면 개발 경험 보유 (주문/반품 조회)
  - SQLite 작업도 조회 패턴이므로 유사함
  - 주문/반품 조회 작업 완료 후 여유 생길 가능성
- ⚠️ **담당자 2는 권장하지 않음**
  - 화면 수는 적지만 복잡도 매우 높음 (6개 테이블 JOIN)
  - 카테고리 필터링 API 다수 개발 필요
  - SQLite 작업 추가 시 과부하 가능성 높음

---

## 📚 참고 문서

- SQLite 로그인 히스토리 스키마: `SQLITE_LOGIN_HISTORY_SCHEMA.md`
- 작업 분담 분석: `WORKLOAD_ANALYSIS.md`
- 최종 작업 분담: `TASK_DISTRIBUTION_FINAL.md`

